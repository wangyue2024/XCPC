# 问题：构造完全图，使得没有一条哈密顿连续出现3n/4条黑/白边

### 1. 问题转化：从排列到路径

一个排列 `p = (p_1, p_2, ..., p_n)` 产生一个视频序列，对应图上的一条路径 `p_1 - p_2 - ... - p_n`。这个路径访问了图上所有的 `n` 个顶点。

“任何排列中连续同类型视频不超过 `K = ⌈3n/4⌉`”
这个约束等价于：
**在最终的染色图中，不存在任何长度超过 `K` 的同色简单路径 (monochromatic simple path)。**

一条长度为 `L` 的路径包含 `L+1` 个顶点。所以，我们的目标是完成图的二染色（用 `F`和 `S`），使得图中：

1. 最长的全 `F` 简单路径长度 `L_F ≤ K`。
2. 最长的全 `S` 简单路径长度 `L_S ≤ K`。

### 2. 构造性解法：寻找一个“好”的结构

既然题目保证总有解，这强烈暗示存在一种构造性的方法。我们可以尝试将所有顶点划分成几个集合，然后根据顶点所在的集合来定义它们之间边的颜色。这种方法可以有效地控制路径的长度。

一个非常有效的构造是**二分图划分 (Bipartition)**。

1. **基本思想**：将所有 `n` 个顶点分成两个集合 `V1` 和 `V2`。
2. **染色规则**：

   * 如果两个顶点 `u, v` **在同一个集合**里 (比如都在 `V1` 或都在 `V2`)，它们之间的边染成 **S** (Scary)。
   * 如果两个顶点 `u, v` **在不同的集合**里 (一个在 `V1`，一个在 `V2`)，它们之间的边染成 **F** (Funny)。
3. **路径长度分析**：

   * **S-路径**：一条全 `S` 的路径必须完全位于 `V1` 内部或 `V2` 内部。因此，最长的 `S` 路径长度最多是 `max(|V1| - 1, |V2| - 1)`。
   * **F-路径**：一条全 `F` 的路径必须在 `V1` 和 `V2` 之间来回交替。例如 `v1 - v2 - v1' - v2' ...` (其中 `v1, v1' ∈ V1`, `v2, v2' ∈ V2`)。这种路径能包含的顶点数最多是 `2 * min(|V1|, |V2|) + 1` (当其中一个集合的顶点用完后，路径可能会再多访问另一个集合的一个顶点)。路径长度最多为 `2 * min(|V1|, |V2|)`。
4. **选择划分大小**：我们的目标是选择 `|V1|` 和 `|V2|` 的大小，使得上述两个路径长度上界都小于等于 `K = ⌈3n/4⌉`。一个非常有效的选择是让其中一个集合非常小。让我们尝试将其中一个集合的大小设为 `m = ⌊n/4⌋`。

   * `|V1| = m = ⌊n/4⌋`
   * `|V2| = n - m = n - ⌊n/4⌋`
   * **检验 S-路径长度**：`max(m-1, n-m-1) = n-m-1 = n - ⌊n/4⌋ - 1`。我们需要 `n - ⌊n/4⌋ - 1 ≤ ⌈3n/4⌉`。这个不等式对于所有 `n ≥ 2` 都是成立的。
   * **检验 F-路径长度**：`2 * min(m, n-m) = 2 * m = 2 * ⌊n/4⌋`。我们需要 `2 * ⌊n/4⌋ ≤ ⌈3n/4⌉`。这个不等式也是成立的（因为 `2n/4 = n/2 ≤ 3n/4`）。

所以，只要我们能找到一种方法，将 `n` 个顶点划分为大小为 `⌊n/4⌋` 和 `n - ⌊n/4⌋` 的两个集合，并且这个划分不与输入中预设的 `F/S` 边冲突，问题就解决了。

### 3. 处理预设的边

输入中已有的 `F` 和 `S` 边对我们的划分提出了要求：

* 如果边 `(u, v)` 是 `F`，那么 `u` 和 `v` 必须被分到**不同**的集合。
* 如果边 `(u, v)` 是 `S`，那么 `u` 和 `v` 必须被分到**相同**的集合。

这本质上是一个带约束的图 2-着色问题。我们可以通过以下步骤解决：

1. **处理'S'约束**：所有必须在同一集合的顶点可以看作一个整体。我们可以使用 **并查集 (Disjoint Set Union, DSU)** 来将这些顶点合并。遍历所有 `(u, v)` 是 `S` 的边，执行 `dsu.unite(u, v)`。这样，每个连通分量（由 DSU 的根节点代表）内的所有原始顶点都必须在最终的同一个大集合里（`V1`或 `V2`）。
2. **处理'F'约束**：`F` 边表示两个顶点（以及它们所在的DSU分量）必须在不同的集合。我们可以建立一个新的 **“约束图”**，其节点是 DSU 分量的根节点。对于每个 `F` 边 `(u, v)`，我们在约束图中连接 `dsu.find(u)` 和 `dsu.find(v)`。
3. **2-着色约束图**：这个约束图必须是二分图（否则约束是矛盾的，但题目保证有解）。我们对这个约束图进行 2-着色（可以用 BFS 或 DFS）。给每个 DSU 分量染上颜色 0 或 1。对于约束图中的每个连通子图，有两种染法（颜色 0 和 1 可以互换）。
4. **选择最终划分（子集和问题）**：现在，我们有若干个“块”（约束图的连通子图）。对于每个块，我们知道它内部如何被 2-着色，比如，`A_k` 是染成颜色 0 的 DSU 分量（的所有原始顶点）的集合，`B_k` 是染成颜色 1 的。我们可以选择将 `A_k` 放入 `V1` 且 `B_k` 放入 `V2`，或者反过来。
   我们的目标是做出这些选择，使得最终的 `|V1|` 恰好等于 `m = ⌊n/4⌋`（或者 `n-m`）。
   这是一个经典的**子集和问题 (Subset Sum Problem)**。

   * 我们有一系列数对 `(|A_1|, |B_1|), (|A_2|, |B_2|), ...`。
   * 我们要从每对中选一个数，使得它们的和等于 `m = ⌊n/4⌋`。
   * 这个问题可以用动态规划解决。设 `dp[k][s]` 为是否可以用前 `k` 个块凑出大小为 `s` 的集合。`dp` 状态可以优化到一维。
   * `dp[s]` = `true` 表示可以凑出大小为 `s` 的集合。
   * `dp[0] = true`。
   * 对于每个数对 `(|A_k|, |B_k|)`，我们更新 `dp` 数组：`new_dp[s + |A_k|] = true` 且 `new_dp[s + |B_k|] = true` 如果 `dp[s]` 是 `true`。
5. **回溯和构建答案**：一旦 `dp` 表格计算完毕，我们检查 `dp[m]` 是否为 `true`。如果不是，我们检查 `dp[n-m]`（因为 `V1` 和 `V2` 是对称的）。题目保证有解，所以其中一个必然为 `true`。然后，我们可以通过回溯 DP 表格找出是哪个选择（`|A_k|` 还是 `|B_k|`）导致了这个结果。

   这样，我们就确定了每个 DSU 分量最终是属于 `V1` 还是 `V2`。从而，每个原始顶点也确定了归属。

### 算法步骤总结

1. 初始化并查集 DSU，`n`个顶点各自独立。
2. 遍历输入矩阵，对于每个 `S` 边 `(i, j)`，执行 `dsu.unite(i, j)`。同时，在 DSU 中维护每个集合的大小。
3. 建立约束图 `G_comp`，节点为 DSU 的根节点。对于每个 `F` 边 `(i, j)`，在 `G_comp` 中连接 `dsu.find(i)` 和 `dsu.find(j)`。
4. 对 `G_comp` 进行 2-着色。遍历 `G_comp` 的每个连通分量，计算出两种着色方案下各自的顶点总数，得到一系列数对 `(size_A, size_B)`。
5. 使用动态规划解决子集和问题，目标和为 `m = ⌊n/4⌋`，找到一种分配方案。
6. 根据 DP 回溯的结果，确定每个 DSU 分量最终的归属（`V1` 或 `V2`）。
7. 生成最终的 `n x n` 答案矩阵。对于任意一对顶点 `(i, j)`：
   * 如果 `dsu.find(i)` 和 `dsu.find(j)` 同属 `V1` 或同属 `V2`，则边为 `S`。
   * 否则，边为 `F`。
8. 打印结果。

这个算法结合了多种经典技术，逻辑清晰，并且能在 `n ≤ 24` 的约束下高效运行。
